# Skill Templates

Templates for creating new skills. Copy and customize.

---

## Minimal Skill Template

For simple skills with just procedures (no scripts):

```markdown
---
name: skill-name
description: Action on object for purpose. Use when trigger.
version: 1.0
---

# Skill Name: Purpose

Brief explanation of what this skill does.

## Quick Start

Most common usage - copy-paste ready.

## Common Scenarios

### Scenario 1: Typical Case
Description and steps.

### Scenario 2: Variant
How to handle variations.

## Error Handling

- **Error X**: Cause → Fix
- **Error Y**: Cause → Fix

---
**Version:** 1.0
```

---

## Enhanced Skill Template

For skills with automation scripts:

```markdown
---
name: skill-name  
description: Action on object for purpose. Use when trigger.
version: 1.0
---

# Skill Name: Purpose

## Quick Start

\`\`\`bash
python scripts/process.py --input data.json
\`\`\`

Expected output: [describe success]

## Prerequisites

- Input format: [specify]
- Required files: [list]

## Common Scenarios

### Scenario 1: Standard Usage
\`\`\`bash
python scripts/process.py --input data.json --output result.json
\`\`\`

### Scenario 2: Validation Only
\`\`\`bash
python scripts/validate.py data.json
\`\`\`

## Error Handling

- **Error X**: Cause → Fix
- **Error Y**: Cause → Fix

## Advanced Usage

See [ADVANCED.md](./resources/ADVANCED.md) for complex scenarios.

---
**Version:** 1.0
```

---

## Script Template

Standard pattern for automation scripts:

```python
#!/usr/bin/env python3
"""
Script Name: Short description

Usage:
    python script_name.py input.json [output.json]

Returns:
    JSON with structured results:
    {
        "status": "success|error",
        "data": {...},
        "errors": [...]
    }
"""

import json
import sys
from pathlib import Path
from typing import Any


def process(input_path: str, output_path: str = None) -> dict[str, Any]:
    """Main processing function."""
    try:
        with open(input_path) as f:
            data = json.load(f)
        
        # Process data
        results = {"processed": [], "errors": []}
        for item in data:
            try:
                results["processed"].append(transform(item))
            except Exception as e:
                results["errors"].append({"item": item.get("id"), "error": str(e)})
        
        # Write output if specified
        if output_path:
            with open(output_path, 'w') as f:
                json.dump(results["processed"], f, indent=2)
        
        return {
            "status": "success" if not results["errors"] else "partial",
            "processed": len(results["processed"]),
            "errors": results["errors"]
        }
    
    except Exception as e:
        return {"status": "error", "message": str(e)}


def transform(item: dict) -> dict:
    """Transform single item - customize this."""
    return item


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    input_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    result = process(input_path, output_path)
    print(json.dumps(result, indent=2))
    sys.exit(0 if result["status"] == "success" else 1)


if __name__ == "__main__":
    main()
```

---

## DIRECTORY_STRUCTURE.txt Template

Auto-generated by `package_skill.py`, but here's the format:

```
skill-name/
├── SKILL.md                    # Main skill file (Layer 1)
├── README.md                   # Deployment instructions
├── DIRECTORY_STRUCTURE.txt     # This file
├── scripts/                    # Automation scripts (Layer 0)
│   ├── process.py
│   └── README.md
└── resources/                  # Reference materials (Layer 2)
    ├── ADVANCED.md
    └── schemas/
        └── schema.json

Token Budget:
- Layer 0 (description): ~25 tokens
- Layer 1 (SKILL.md): ~400 tokens
- Layer 2 (resources/): ~1000 tokens (loaded selectively)

Version: 1.0
Created: YYYY-MM-DD
```
